(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
const vis = window.vis
const {createNodesAndDataset} = require("./vis/parseJsonToVis")

class ConceptC {
  constructor (options, inputJson={}) {
    this.options = new Options(options)
    let data = createNodesAndDataset(inputJson)
    let container = document.getElementById(this.options.container_id);
    this.visNetwork = new vis.Network(container, data, this.options.visOptions)
  }
}
class Options {
  constructor (optionsObj) {
    let {
      container_id,
      visOptions={}
    } = optionsObj
    this.container_id = container_id
    this.visOptions = visOptions
  }
}
window.ConceptC = ConceptC
},{"./vis/parseJsonToVis":3}],2:[function(require,module,exports){
require("./index")
},{"./index":1}],3:[function(require,module,exports){
module.exports = {
  createNodesAndDataset
}

function createNodesAndDataset (data) {
  let {nodesArray, edgesArray} = a(null, data, [], [])
  return {
    nodes: new vis.DataSet(nodesArray),
    edges: new vis.DataSet(edgesArray)
  }
}
function nodeColor (parent_relationship) {
  switch (parent_relationship) {
    case "contradicts":
      return "red"
    case "supports":
      return "green"
    case "maybe_supports":
      return "green"
    case "inherit":
      return null
    default:
      console.error("invalid relationship")
      return null
  }
}
function nodeShape (type) {
  switch (type) {
    case "concept":
      return "box"
    case "term":
      return "ellipse"
    default:
      console.error("invalid type")
      return null
  }
}
function a (parent, current_node, nodesArray, edgesArray) {
  let {name, type="concept", parent_relationship="inherit", meta, children} = current_node
  let current = {
    label: name,
    id: (nodesArray.length || 0) + 1,
    parent_relationship
  }
  if(parent){
    if(current.parent_relationship === "inherit"){
      current.parent_relationship = parent.parent_relationship
    }
    edgesArray.push({
      from: parent.id,
      to: current.id
    })
  }
  current.color = nodeColor(current.parent_relationship)
  current.shape = nodeShape(type)
  nodesArray.push(current)
  if(current_node.children){
    for(let node of current_node.children){
      let result = a(current, node, nodesArray, edgesArray)
      nodesArray = result.nodesArray
      edgesArray = result.edgesArray
    }
  }
  return {
    nodesArray,
    edgesArray
  }
}
},{}]},{},[2]);
